{"meta":{"title":"黑米面包派のBlog","subtitle":"","description":"闲暇定终身","author":"黑米面包派","url":"https://www.wujiwen.cn","root":"/"},"pages":[{"title":"tags","date":"2020-01-20T02:07:43.000Z","updated":"2020-04-08T10:08:38.307Z","comments":true,"path":"tags/index.html","permalink":"https://www.wujiwen.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-20T02:09:18.000Z","updated":"2020-01-20T02:10:57.966Z","comments":true,"path":"categories/index.html","permalink":"https://www.wujiwen.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"【认证与授权】Spring Security自定义页面","slug":"spring/security/security-cap06","date":"2020-05-07T12:49:58.000Z","updated":"2020-05-08T14:16:30.704Z","comments":true,"path":"2020/05/07/spring/security/security-cap06/","link":"","permalink":"https://www.wujiwen.cn/2020/05/07/spring/security/security-cap06/","excerpt":"在前面的篇幅中，我们对认证和授权流程大致梳理了一遍。在这个过程中我们一直都是使用系统生成的默认页面，登录成功后也是直接调转到根路径页面。而在实际的开发过程中，我们是需要自定义登录页面的，有时还会添加各类验证机制，在登录成功后会跳转至指定页面，还会进行各种美化，甚至是前后端分离的方式。这时，就需要我们对自定义登录进行实现。 本章节使用spring-security-custom-login","text":"在前面的篇幅中，我们对认证和授权流程大致梳理了一遍。在这个过程中我们一直都是使用系统生成的默认页面，登录成功后也是直接调转到根路径页面。而在实际的开发过程中，我们是需要自定义登录页面的，有时还会添加各类验证机制，在登录成功后会跳转至指定页面，还会进行各种美化，甚至是前后端分离的方式。这时，就需要我们对自定义登录进行实现。 本章节使用spring-security-custom-login 一、工程准备1、pom.xml12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;security-study&lt;/artifactId&gt; &lt;groupId&gt;cn.wujiwen.security&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;description&gt;自定义登录页面&lt;/description&gt; &lt;artifactId&gt;spring-security-custom-login&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 我们引入了thymeleaf,也是官方推荐的做法。 2、application.yml123456789server: port: 8080spring: security: user: name: admin password: admin roles: ADMIN 非常的熟悉，端口、基础用户等信息 3、启动类Application123456@SpringBootApplicationpublic class SecurityLoginApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityLoginApplication.class,args); &#125;&#125; 二、自定义SecurityConfig自定义SecurityConfig需继承WebSecurityConfigurerAdapter并重写相关配置即可，由于今天只涉及到自定义页面的信息，所以我们只需要重写configure(HttpSecurity http) 方法即可。在重写这个方法前，我们先来看一下原来这个方法是干什么的。 1234567891011protected void configure(HttpSecurity http) throws Exception &#123; http // 1 声明ExpressionUrlAuthorizationConfigurer，要求所有URL必须登录认证后才能访问 .authorizeRequests().anyRequest().authenticated() .and() // 2 声明一个默认的FormLoginConfigurer .formLogin() .and() // 3 声明一个默认的HttpBasicConfigurer .httpBasic();&#125; 对任何请求要求用户已认证(通俗地讲，用户必须先登录才能访问任何资源); 启用用户名密码表单登录认证机制; 启用Http Basic认证机制; 下面我们就通过重写上述的方法来做到自定义登录页面等信息 12345678910111213141516@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable(); http.authorizeRequests().anyRequest().authenticated() .and().httpBasic().and() // 1 .formLogin().loginPage(\"/login\") // 2 .loginProcessingUrl(\"/loginAction\") // 3 .defaultSuccessUrl(\"/index\") .permitAll(); &#125;&#125; 我们发现其实和缺省方法中并没有太大的差别，只有三处的变化 loginPage()中将指定自定义登录页面的请求路径 loginProcessingUrl() 为认证的请求接口，也就是我们常说的form表单中的action。如果不指定，将采用loginPage中的值。 defaultSuccessUrl()为认证成功后跳转的页面地址 三、自定义页面在springboot中使用html页面这里就不过多赘述，一般情况下在resource下新建templates文件下，将需要的页面放到该文件下即可。我的路径为 1234_resource |_templates |_login.html |_index.html 1、login.thml1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;Spring Security Example &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:if=\"$&#123;param.error&#125;\"&gt; 用户名或密码错误&lt;/div&gt;&lt;div th:if=\"$&#123;param.logout&#125;\"&gt; 你已经退出&lt;/div&gt;&lt;form th:action=\"@&#123;/loginAction&#125;\" method=\"post\"&gt; &lt;div&gt;&lt;label&gt; 账号 : &lt;input type=\"text\" name=\"username\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 密码 : &lt;input type=\"password\" name=\"password\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"登录\"/&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这里我将action与loginProcessingUrl()对应，你也可以自己尝试更换或使用默认或与loginPage()一致的。 到这里我们就完成了一个最简单的表单提交的页面了。当我们点击submit按钮时，正确的请求路径将是 curl -x POST -d &quot;username=admin&amp;password=admin&quot; http://127.0.0.1:8080/loginAction 这里可能会有个疑问了，为啥你的参数就是username和password呢？嗯～ 当然可以自己指定的啊，因为在FormLoginConfigurer中默认的指定参数 12345public FormLoginConfigurer() &#123; super(new UsernamePasswordAuthenticationFilter(), null); usernameParameter(\"username\"); passwordParameter(\"password\"); &#125; 2、index.html12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;Spring Security Example&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h2&gt;Welcome &lt;b th:text=\"$&#123;username&#125;\"&gt;&lt;/b&gt;&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; 这是个认证成功后的欢迎页面，比较简单，显示当前登录用户即可 四、BaseContoller上面我们定义了各类路径和请求地址，接下来我们需要定义如果将这些页面映射出来 1234567891011121314@Controllerpublic class BaseController &#123; // loginPage(\"/login\") 将跳转到login.html @GetMapping(\"/login\") public String login() &#123; return \"login\"; &#125; // index.html @RequestMapping(\"/index\") public String index(Model model, HttpServletRequest request) &#123; model.addAttribute(\"username\",request.getUserPrincipal().getName()); return \"index\"; &#125;&#125; 五、测试 到这里我们已经完成了一个简单的自定义登录页面的改造了。当然，在实际的项目中需要自定义的东西还有很多很多，比如，当认证不通过时如果操作，当用户退出登录时如果操作，这些都没有去实现。 还有人会说，这都什么年代了，前后端分离啊，这些都可以通过一步步的改造来实现的。 （完）","categories":[],"tags":[{"name":"spring security","slug":"spring-security","permalink":"https://www.wujiwen.cn/tags/spring-security/"}]},{"title":"【认证与授权】Spring Security的授权流程","slug":"spring/security/security-cap05","date":"2020-04-16T13:54:56.000Z","updated":"2020-04-18T07:53:19.624Z","comments":true,"path":"2020/04/16/spring/security/security-cap05/","link":"","permalink":"https://www.wujiwen.cn/2020/04/16/spring/security/security-cap05/","excerpt":"上一篇我们简单的分析了一下认证流程，通过程序的启动加载了各类的配置信息。接下来我们一起来看一下授权流程，争取完成和前面简单的web基于sessin的认证方式一致。由于在授权过程中，我们预先会给用于设置角色，关于如果加载配置的角色信息这里就不做介绍了，上一篇的加载过程中我们可以发现相关的信息。 本篇依旧基于spring-security-basic","text":"上一篇我们简单的分析了一下认证流程，通过程序的启动加载了各类的配置信息。接下来我们一起来看一下授权流程，争取完成和前面简单的web基于sessin的认证方式一致。由于在授权过程中，我们预先会给用于设置角色，关于如果加载配置的角色信息这里就不做介绍了，上一篇的加载过程中我们可以发现相关的信息。 本篇依旧基于spring-security-basic 配置角色信息配置用户及其角色信息的方式很多，我们这次依旧采取配置文件的方式，不用代码或其他的配置方式，在之前的配置用户信息的地方application.yml，添加用户的角色信息。 123456spring: security: user: name: admin password: admin roles: ADMIN,USER 这样我们就完成了最简单的用户角色赋予。在加载用户信息时我们知道会生成一个User对象，将其用户名、密码、权限信息封装进去。 这里需要注意一下关于role信息的加载 12345678910public UserBuilder roles(String... roles) &#123; List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;( roles.length); for (String role : roles) &#123; Assert.isTrue(!role.startsWith(\"ROLE_\"), () -&gt; role + \" cannot start with ROLE_ (it is automatically added)\"); authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role)); &#125; return authorities(authorities);&#125; 也就是说我们上方配置的ADMIN,USER会被转化成ROLE_ADMIN,ROLE_USER 1、获取用户信息我们在BasicController类中添加一个获取认证用户信息的接口 12345678910111213141516@RequestMapping(\"/getUser\")public String api(HttpServletRequest request) &#123; // 方式一 Principal userPrincipal = request.getUserPrincipal(); UsernamePasswordAuthenticationToken user = ((UsernamePasswordAuthenticationToken) userPrincipal); System.out.println(user.toString()); // 方式二 SecurityContext securityContext = SecurityContextHolder.getContext(); System.out.println(securityContext.getAuthentication()); // 方式三 Object context = request.getSession().getAttribute(\"SPRING_SECURITY_CONTEXT\"); SecurityContext securityContext1 = (SecurityContext) context; System.out.println(securityContext1.getAuthentication()); return user.toString();&#125; 我们从session中去获取用户的信息，然后拿到其授权信息就可以做相应的判断了request.getSession().getAttribute(&quot;SPRING_SECURITY_CONTEXT&quot;);这一段代码我们找到是在HttpSessionSecurityContextRepository.saveContext(SecurityContext context)中放入的，SPRING_SECURITY_CONTEXT是其维护的常量，这样我们就有可以根据这个key去获取当前的会话信息了。 当然我们还有另外的获取用户信息的方式还记得我们在AbstractAuthenticationProcessingFilter这个核心过滤器中的successfulAuthentication方法 123456789101112131415161718192021protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \" + authResult); &#125; SecurityContextHolder.getContext().setAuthentication(authResult); rememberMeServices.loginSuccess(request, response, authResult); // Fire event if (this.eventPublisher != null) &#123; eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent( authResult, this.getClass())); &#125; successHandler.onAuthenticationSuccess(request, response, authResult);&#125; 这里将其认证成功的结果信息放入到上下文中 SecurityContextHolder.getContext().setAuthentication(authResult);那我们也是可以直接通过其get方法获取SecurityContextHolder.getContext(); 登陆后直接访问接口localhost:8080/getUser 123org.springframework.security.authentication.UsernamePasswordAuthenticationToken@bade0105: Principal: org.springframework.security.core.userdetails.User@586034f: Username: admin; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_ADMIN; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@fffbcba8: RemoteIpAddress: 0:0:0:0:0:0:0:1; SessionId: E4C77C8791C314B7B14F796B0DD38F13; Granted Authorities: ROLE_ADMINorg.springframework.security.authentication.UsernamePasswordAuthenticationToken@bade0105: Principal: org.springframework.security.core.userdetails.User@586034f: Username: admin; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_ADMIN; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@fffbcba8: RemoteIpAddress: 0:0:0:0:0:0:0:1; SessionId: E4C77C8791C314B7B14F796B0DD38F13; Granted Authorities: ROLE_ADMINorg.springframework.security.authentication.UsernamePasswordAuthenticationToken@bade0105: Principal: org.springframework.security.core.userdetails.User@586034f: Username: admin; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_ADMIN; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@fffbcba8: RemoteIpAddress: 0:0:0:0:0:0:0:1; SessionId: E4C77C8791C314B7B14F796B0DD38F13; Granted Authorities: ROLE_ADMIN 可以看到，控制台打印的三段信息是完全一样的。说明这里通过三种方式获取的用户信息是一致的。既然可以获取到当前登录的用户信息，接下来我们就可以通过用户信息的判断来决定其是否可以访问那些接口。 2、自定义拦截器上一步我们通过三种方式获取到了认证用户的信息，这里我们将设计一个拦截器来控制用户的访问权限。我们先设计两个接口，一个只能admin角色用户才可以访问，一个只能user角色用户才可以访问 12345678910111213@RequestMapping(\"/api/admin\")public String adminApi(HttpServletRequest request)&#123; Principal principal = request.getUserPrincipal(); String name = principal.getName(); return \"管理员：\" + name + \"你好，你可以访问/api/admin\";&#125;@RequestMapping(\"/api/user\")public String userApi(HttpServletRequest request)&#123; Principal principal = request.getUserPrincipal(); String name = principal.getName(); return \"普通用户：\" + name + \"你好，你可以访问/api/user\";&#125; 我们设计了两个接口，通过url来区别不同角色访问的结果，我们再设计一个拦截器，这里我们可以直接参考前面的文章 基于session的认证方式 中定义的拦截器 1234567891011121314151617181920212223242526272829303132public class AuthenticationInterceptor extends HandlerInterceptorAdapter &#123; private final static String USER_SESSION_KEY = \"SPRING_SECURITY_CONTEXT\"; // 前置拦截，在接口访问前处理 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object attribute = request.getSession().getAttribute(USER_SESSION_KEY); if (attribute == null) &#123; writeContent(response,\"匿名用户不可访问\"); return false; &#125; else &#123; SecurityContext context = (SecurityContext) attribute; Collection&lt;? extends GrantedAuthority&gt; authorities = context.getAuthentication().getAuthorities(); for (GrantedAuthority authority : authorities) &#123; if (authority.getAuthority().equals(\"ROLE_ADMIN\") &amp;&amp; request.getRequestURI().contains(\"admin\"))&#123; return true; &#125; if (authority.getAuthority().equals(\"ROLE_USER\") &amp;&amp; request.getRequestURI().contains(\"user\"))&#123; return true; &#125; &#125; writeContent(response,\"权限不足\"); return false; &#125; &#125; //响应输出 private void writeContent(HttpServletResponse response, String msg) throws IOException &#123; response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"application/json;charset=utf‐8\"); PrintWriter writer = response.getWriter(); writer.write(msg); &#125;&#125; 同时生效该拦截器 12345678@Configurationpublic class WebSecurityConfig implements WebMvcConfigurer &#123; // 添加自定义拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new AuthenticationInterceptor()).addPathPatterns(\"/api/**\"); &#125;&#125; 3、注解方式判断通过拦截器的方式配置，看上去非常的繁琐，如果我需要给某个接口添加一个角色访问权限，还需要去修改拦截器中的判断逻辑。当然Spring Security也提供了非常方便的注解模式去控制接口，需要修改哪个接口的角色访问，直接在接口上修改就可以了 1234567891011@PreAuthorize(\"hasRole('ADMIN')\")@RequestMapping(\"/api2/admin\")public String admin2Api(String message)&#123; return \"hello : \" + message;&#125;@PreAuthorize(\"hasRole('USER')\")@RequestMapping(\"/api2/user\")public String user2Api(String message)&#123; return \"hello : \" + message;&#125; 非常的简单，一个注解就帮我们解决了拦截器中完成的事情，其实他们的原理是差不多的。不过这里有几个需要关注的点 @PreAuthorize注解的生效，需要提前开启的。需要在@EnableGlobalMethodSecurity(prePostEnabled = true) 注解中生效，因为PreAuthorize 默认是false @PreAuthorize是支持表达式方式进行设置的，我用的是hasRole。是其内置的表达式库SecurityExpressionRoot中的方法 hasRole最终调用的是hasAnyAuthorityName的方法，这里会有一个缺省的前缀，当前你也可以写成hasRole(‘ROLE_ADMIN’)的。并且是变长数组，我们还可一进行多角色的判断例如：hasRole(‘ROLE’,’USER’) 123456789101112private boolean hasAnyAuthorityName(String prefix, String... roles) &#123; Set&lt;String&gt; roleSet = getAuthoritySet(); for (String role : roles) &#123; String defaultedRole = getRoleWithDefaultPrefix(prefix, role); if (roleSet.contains(defaultedRole)) &#123; return true; &#125; &#125; return false;&#125; 到这里，我们已经完成了基于拦截器和注解方式的接口授权设置，基本上都是在零配置的基础上完成的。我们写发现了，好像不太容易扩展信息，例如application.yml中没办法同时设置多个用户，认证成功后我想跳转到自定义的页面或者自定义的信息。别急，从下一篇开始，我们将逐步对代码进行改造，一步一步打造成你想满足的各种需求 （完）","categories":[],"tags":[{"name":"spring security","slug":"spring-security","permalink":"https://www.wujiwen.cn/tags/spring-security/"}]},{"title":"【认证与授权】Spring Security系列之认证流程解析","slug":"spring/security/security-cap04","date":"2020-04-12T05:36:47.000Z","updated":"2020-04-12T14:51:32.900Z","comments":true,"path":"2020/04/12/spring/security/security-cap04/","link":"","permalink":"https://www.wujiwen.cn/2020/04/12/spring/security/security-cap04/","excerpt":"上面我们一起开始了Spring Security的初体验，并通过简单的配置甚至零配置就可以完成一个简单的认证流程。可能我们都有很大的疑惑，这中间到底发生了什么，为什么简单的配置就可以完成一个认证流程啊，可我啥都没看见，没有写页面，没有写接口。这一篇我们将深入到源码层面一起来了解一下spring security到底是怎么工作的。 准备工作在开始源码理解前，我们先来做一项基本的准备工作，从日志中去发现线索，因为我们发现什么都没有配置的情况下，他也可以正常的工作，并给我们预置了一个临时的用户user。那么他肯定是在工程启动的时候做了什么事情，上一篇我们也提到了是如果生成user用户和密码的。这篇我们将仔细的去了解一下。","text":"上面我们一起开始了Spring Security的初体验，并通过简单的配置甚至零配置就可以完成一个简单的认证流程。可能我们都有很大的疑惑，这中间到底发生了什么，为什么简单的配置就可以完成一个认证流程啊，可我啥都没看见，没有写页面，没有写接口。这一篇我们将深入到源码层面一起来了解一下spring security到底是怎么工作的。 准备工作在开始源码理解前，我们先来做一项基本的准备工作，从日志中去发现线索，因为我们发现什么都没有配置的情况下，他也可以正常的工作，并给我们预置了一个临时的用户user。那么他肯定是在工程启动的时候做了什么事情，上一篇我们也提到了是如果生成user用户和密码的。这篇我们将仔细的去了解一下。 1、首先我们配置在applicaiton.yml中调整一下日志级别 123logging: level: org.springframework.security: debug 我们将security相关的日志打印出来，一起来启动或者运行的时候到底发生了什么。 2、启动spring-security-basic 工程 !!!找到了 日志过滤1234(1) Eagerly initializing &#123;org.springframework.boot.autoconfigure.security.servlet.WebSecurityEnablerConfiguration&#x3D;org.springframework.boot.autoconfigure.security.servlet.WebSecurityEnablerConfiguration@52e04737&#125;(2) Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).(3) Adding web access control expression &#39;authenticated&#39;, for any request(4) Validated configuration attributes 逐个解析1、WebSecurityEnablerConfiguration告诉我们它初始化了一个配置类WebSecurityEnablerConfiguration 不管！找到源码再说 123456789101112131415@Configuration( proxyBeanMethods = false)@ConditionalOnBean(&#123;WebSecurityConfigurerAdapter.class&#125;)@ConditionalOnMissingBean( name = &#123;\"springSecurityFilterChain\"&#125;)@ConditionalOnWebApplication( type = Type.SERVLET)@EnableWebSecuritypublic class WebSecurityEnablerConfiguration &#123; public WebSecurityEnablerConfiguration() &#123; &#125;&#125; ？？？怎么只有这么一点东西，这个类为什么会在初始化的时候启动？这里简单的指出来 首先找到spring-boot-autoconfigure-版本.jar下的META-INF/spring.factorites文件，其中有这样一段 123org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\ 我们可以暂时不去深究这是什么意思，总之，在springboot启动的时候，会将这里配置走一遍（后期可能也会写一点关于springboot启动原理的文章…）我们一个一个来看一下 1.1 SecurityAutoConfiguration12345678910111213141516@Configuration( proxyBeanMethods = false)@ConditionalOnClass(&#123;DefaultAuthenticationEventPublisher.class&#125;)@EnableConfigurationProperties(&#123;SecurityProperties.class&#125;)@Import(&#123;SpringBootWebSecurityConfiguration.class, WebSecurityEnablerConfiguration.class, SecurityDataConfiguration.class&#125;)public class SecurityAutoConfiguration &#123; public SecurityAutoConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean(&#123;AuthenticationEventPublisher.class&#125;) public DefaultAuthenticationEventPublisher authenticationEventPublisher(ApplicationEventPublisher publisher) &#123; return new DefaultAuthenticationEventPublisher(publisher); &#125;&#125; 在这个类中我们重点关注 12@EnableConfigurationProperties(&#123;SecurityProperties.class&#125;)@Import(&#123;SpringBootWebSecurityConfiguration.class, WebSecurityEnablerConfiguration.class, SecurityDataConfiguration.class&#125;) 首先是SecurityProperties 1234567891011121314151617181920212223242526272829@ConfigurationProperties( // A 前缀 prefix = \"spring.security\")public class SecurityProperties &#123; // .. private SecurityProperties.User user = new SecurityProperties.User(); // ... public static class User &#123; // 默认指定一个 private String name = \"user\"; // 默认随机密码 private String password = UUID.randomUUID().toString(); private List&lt;String&gt; roles = new ArrayList(); // 默认密码是系统生成的（重点关注一下） private boolean passwordGenerated = true; // ... public void setPassword(String password) &#123; // 如果指定了自定义了密码，那就false 并覆盖password if (StringUtils.hasLength(password)) &#123; this.passwordGenerated = false; this.password = password; &#125; &#125; //..... &#125; // .....&#125; 篇幅问题这里我删除了很多代码。直接看里面的注释就好了，这也就是为什么我们不配置任何信息，也有一个默认的用户，以及我们用配置信息覆盖了默认用户的关键信息所在。 其次是@Import注解，这个其实就是xml配置方式中的标签 引入另外的配置，这里引入了SpringBootWebSecurityConfiguration WebSecurityEnablerConfiguration SecurityDataConfiguration 12345678910111213141516171819202122@Configuration( proxyBeanMethods &#x3D; false)@ConditionalOnClass(&#123;WebSecurityConfigurerAdapter.class&#125;)@ConditionalOnMissingBean(&#123;WebSecurityConfigurerAdapter.class&#125;)@ConditionalOnWebApplication( type &#x3D; Type.SERVLET)public class SpringBootWebSecurityConfiguration &#123; public SpringBootWebSecurityConfiguration() &#123; &#125; @Configuration( proxyBeanMethods &#x3D; false ) &#x2F;&#x2F; 其实也没干啥，就是一个空的对象，什么也没覆盖 @Order(2147483642) static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter &#123; DefaultConfigurerAdapter() &#123; &#125; &#125;&#125; 他们指向了一个关键的配置@ConditionalOnBean({WebSecurityConfigurerAdapter.class}) 需要WebSecurityConfigurerAdapter才会进行加载，那这个关键的类是什么时候加载的呢？这就回到了我们在日志中发现的第一个加载的类信息WebSecurityEnablerConfiguration 上面有个一非常关键的注解@EnableWebSecurity 瞧瞧干了啥 1234567891011121314151617@Retention(value &#x3D; java.lang.annotation.RetentionPolicy.RUNTIME)@Target(value &#x3D; &#123; java.lang.annotation.ElementType.TYPE &#125;)@Documented&#x2F;&#x2F; 引入了配置类 WebSecurityConfiguration@Import(&#123; WebSecurityConfiguration.class, SpringWebMvcImportSelector.class, OAuth2ImportSelector.class &#125;)@EnableGlobalAuthentication@Configurationpublic @interface EnableWebSecurity &#123; &#x2F;** * Controls debugging support for Spring Security. Default is false. * @return if true, enables debug support with Spring Security *&#x2F; boolean debug() default false;&#125; 1.2 WebSecurityConfiguration原来，首先他是个配置注解，也import了WebSecurityConfiguration 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Configuration(proxyBeanMethods = false)public class WebSecurityConfiguration implements ImportAware, BeanClassLoaderAware &#123; // 1、声明一个 webSecurity 一起来看一下他是什么时候初始化的 private WebSecurity webSecurity; // 2、是否为调试模式 private Boolean debugEnabled; private List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers; private ClassLoader beanClassLoader; // 3、关键点，后置对象处理器，用来初始化对象 @Autowired(required = false) private ObjectPostProcessor&lt;Object&gt; objectObjectPostProcessor; @Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception &#123; boolean hasConfigurers = webSecurityConfigurers != null &amp;&amp; !webSecurityConfigurers.isEmpty(); // 6 、如果每没初始化，直接指定获取对象 WebSecurityConfigurerAdapter if (!hasConfigurers) &#123; WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() &#123; &#125;); webSecurity.apply(adapter); &#125; // 7、 开始构建对象 webSecurity return webSecurity.build(); &#125; // 4、通过setter方式注入 webSecurityConfigurers @Autowired(required = false) public void setFilterChainProxySecurityConfigurer( ObjectPostProcessor&lt;Object&gt; objectPostProcessor, // 获取 0 步中获取到的对象信息 @Value(\"#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;\") List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers) throws Exception &#123; // 5、 这里通过后置对象处理器来进行 webSecurity 的初始化 webSecurity = objectPostProcessor.postProcess(new WebSecurity(objectPostProcessor)); if (debugEnabled != null) &#123; webSecurity.debug(debugEnabled); &#125; webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE); Integer previousOrder = null; Object previousConfig = null; for (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) &#123; Integer order = AnnotationAwareOrderComparator.lookupOrder(config); if (previousOrder != null &amp;&amp; previousOrder.equals(order)) &#123; throw new IllegalStateException( \"@Order on WebSecurityConfigurers must be unique. Order of \" + order + \" was already used on \" + previousConfig + \", so it cannot be used on \" + config + \" too.\"); &#125; previousOrder = order; previousConfig = config; &#125; for (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) &#123; // 放入到 AbstractConfiguredSecurityBuilder 的配置集合中 webSecurity.apply(webSecurityConfigurer); &#125; this.webSecurityConfigurers = webSecurityConfigurers; &#125; // 0 先自动织入webSecurityConfigurers // 关键点就是获取 beanFactory.getBeansOfType(WebSecurityConfigurer.class); @Bean public static AutowiredWebSecurityConfigurersIgnoreParents autowiredWebSecurityConfigurersIgnoreParents( ConfigurableListableBeanFactory beanFactory) &#123; return new AutowiredWebSecurityConfigurersIgnoreParents(beanFactory); &#125;&#125; 上面我们已经看到了步骤7，通常情况下都会去build 1234567891011121314151617181920212223public abstract class AbstractSecurityBuilder&lt;O&gt; implements SecurityBuilder&lt;O&gt; &#123; private AtomicBoolean building = new AtomicBoolean(); private O object; public final O build() throws Exception &#123; if (this.building.compareAndSet(false, true)) &#123; // 这里调用doBuild的最终方法 this.object = doBuild(); return this.object; &#125; throw new AlreadyBuiltException(\"This object has already been built\"); &#125; public final O getObject() &#123; if (!this.building.get()) &#123; throw new IllegalStateException(\"This object has not been built\"); &#125; return this.object; &#125; // 这里是抽象方法，直接找到其唯一的子类 AbstractConfiguredSecurityBuilder protected abstract O doBuild() throws Exception;&#125; 1234567891011121314151617@Override protected final O doBuild() throws Exception &#123; synchronized (configurers) &#123; buildState = BuildState.INITIALIZING; // 前置检查 beforeInit(); // 初始化 init(); buildState = BuildState.CONFIGURING; beforeConfigure(); configure(); buildState = BuildState.BUILDING; O result = performBuild(); buildState = BuildState.BUILT; return result; &#125; &#125; 不知不觉我们已经找到了spring中的关键方法init了，很多时候我们在定义接口是都会有一个init方法来定义注入时调用 前面我们知道 SpringBootWebSecurityConfiguration初始化了一个对象，同时也通过AutowiredWebSecurityConfigurersIgnoreParents拿到了WebSecurityConfigurerAdapter的子类 DefaultConfigurerAdapter，现在开始init(),其实就是开始WebSecurityConfigurerAdapter的init()方法。说了这里可能有的同学就会比较熟悉了，这就是关键配置的适配器类。 代码稍后贴出来，暂时先不看，到这里为止，我们才梳理了springboot自动配置中的SecurityAutoConfiguration 下面我们才开始第二个类 2、 UserDetailsServiceAutoConfiguration123456789101112131415161718192021222324252627282930313233343536373839@Configuration( proxyBeanMethods = false)@ConditionalOnClass(&#123;AuthenticationManager.class&#125;)@ConditionalOnBean(&#123;ObjectPostProcessor.class&#125;)@ConditionalOnMissingBean( value = &#123;AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class&#125;, type = &#123;\"org.springframework.security.oauth2.jwt.JwtDecoder\", \"org.springframework.security.oauth2.server.resource.introspection.OpaqueTokenIntrospector\"&#125;)public class UserDetailsServiceAutoConfiguration &#123; private static final String NOOP_PASSWORD_PREFIX = \"&#123;noop&#125;\"; private static final Pattern PASSWORD_ALGORITHM_PATTERN = Pattern.compile(\"^\\\\&#123;.+&#125;.*$\"); private static final Log logger = LogFactory.getLog(UserDetailsServiceAutoConfiguration.class); public UserDetailsServiceAutoConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean( type = &#123;\"org.springframework.security.oauth2.client.registration.ClientRegistrationRepository\"&#125; ) // 这里加载了从配置文件或者默认生成的用户信息，以及加密方法 @Lazy public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties, ObjectProvider&lt;PasswordEncoder&gt; passwordEncoder) &#123; User user = properties.getUser(); List&lt;String&gt; roles = user.getRoles(); return new InMemoryUserDetailsManager(new UserDetails[]&#123;org.springframework.security.core.userdetails.User.withUsername(user.getName()).password(this.getOrDeducePassword(user, (PasswordEncoder)passwordEncoder.getIfAvailable())).roles(StringUtils.toStringArray(roles)).build()&#125;); &#125; private String getOrDeducePassword(User user, PasswordEncoder encoder) &#123; String password = user.getPassword(); if (user.isPasswordGenerated()) &#123; logger.info(String.format(\"%n%nUsing generated security password: %s%n\", user.getPassword())); &#125; return encoder == null &amp;&amp; !PASSWORD_ALGORITHM_PATTERN.matcher(password).matches() ? \"&#123;noop&#125;\" + password : password; &#125;&#125; 这里也出现了一个info日志，当我们使用默认user用户时，密码会从这里打印在控制台 这个配置类的关键就是生成一个默认的InMemoryUserDetailsManager对象。 4、SecurityFilterAutoConfiguration这个类就不详细介绍了，就是注册一些过滤器。 回到WebSecurityConfigurerAdapter 这个适配器类，我们关注基本的init()方法，其他的都是一些默认的配置 12345678public void init(final WebSecurity web) throws Exception &#123; final HttpSecurity http = getHttp(); web.addSecurityFilterChainBuilder(http).postBuildAction(() -&gt; &#123; FilterSecurityInterceptor securityInterceptor = http .getSharedObject(FilterSecurityInterceptor.class); web.securityInterceptor(securityInterceptor); &#125;);&#125; 这里有一个关键的方法getHttp() 1234567891011121314151617181920212223242526272829303132333435363738394041424344protected final HttpSecurity getHttp() throws Exception &#123; if (http != null) &#123; return http; &#125; DefaultAuthenticationEventPublisher eventPublisher = objectPostProcessor .postProcess(new DefaultAuthenticationEventPublisher()); localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher); AuthenticationManager authenticationManager = authenticationManager(); authenticationBuilder.parentAuthenticationManager(authenticationManager); authenticationBuilder.authenticationEventPublisher(eventPublisher); // 获取创建共享的对象 Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects(); http = new HttpSecurity(objectPostProcessor, authenticationBuilder, sharedObjects); if (!disableDefaults) &#123; // @formatter:off http .csrf().and() .addFilter(new WebAsyncManagerIntegrationFilter()) .exceptionHandling().and() .headers().and() .sessionManagement().and() .securityContext().and() .requestCache().and() .anonymous().and() .servletApi().and() .apply(new DefaultLoginPageConfigurer&lt;&gt;()).and() .logout(); // @formatter:on ClassLoader classLoader = this.context.getClassLoader(); List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers = SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader); for (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123; http.apply(configurer); &#125; &#125; // httpHttpSecurity 的表单配置 configure(http); return http;&#125; 我们简单列举几个重要的方法 1234567// 根据系统加载的AuthenticationManagerBuilder 在装配用户protected UserDetailsService userDetailsService() &#123; AuthenticationManagerBuilder globalAuthBuilder = context .getBean(AuthenticationManagerBuilder.class); return new UserDetailsServiceDelegator(Arrays.asList( localConfigureAuthenticationBldr, globalAuthBuilder)); &#125; 123456789101112protected void configure(HttpSecurity http) throws Exception &#123; logger.debug(\"Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).\"); // 资源保护 http .authorizeRequests() .anyRequest().authenticated() .and() // 认证页面 .formLogin().and() // HTTP Basic authentication. .httpBasic(); &#125; 上面我们都是通过启动日志的信息来理解应用在启动时到底做了什么，加载了什么关键信息，接下来我们将通过运行时的日志看来看一下我们在认证过程中是如何进行用户名密码的校验的。 登录流程我们打开浏览器输入localhost:8080 由于我们没有进行登录，所以会被redirecting到登录页面。我们一起过滤一下控制台信息，抓取到关键的信息。 我们看到，这里加载了各种过滤器，当访问/时没发现并没有登录，则重定向到默认的/login页面，这也是spirng security的核心。今天重点讨论登录流程，我们先清空控制台，用正确的用户名和密码登录进去。 从控制台我们可以看到很多的过滤器，我们至关注认证流程的一部分，已上图为准。 1、UsernamePasswordAuthenticationFilter这理解这个过滤器前，我们先从他的父类AbstractAuthenticationProcessingFilter 入手，既然是过滤器，我们既要入doFilter入手， 这里是关键的流程，子类只是做具体的实现，我们稍后再看 123456789101112131415161718192021222324252627282930313233343536public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; // 请求的转化 HttpServletRequest request = (HttpServletRequest)req; HttpServletResponse response = (HttpServletResponse)res; if (!this.requiresAuthentication(request, response)) &#123; chain.doFilter(request, response); &#125; else &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Request is to process authentication\"); &#125; Authentication authResult; try &#123; // 关键的认证方法，交由子类来实现，我们到子类看 authResult = this.attemptAuthentication(request, response); if (authResult == null) &#123; return; &#125; this.sessionStrategy.onAuthentication(authResult, request, response); &#125; catch (InternalAuthenticationServiceException var8) &#123; this.logger.error(\"An internal error occurred while trying to authenticate the user.\", var8); this.unsuccessfulAuthentication(request, response, var8); return; &#125; catch (AuthenticationException var9) &#123; this.unsuccessfulAuthentication(request, response, var9); return; &#125; if (this.continueChainBeforeSuccessfulAuthentication) &#123; chain.doFilter(request, response); &#125; // 返回认证成功 this.successfulAuthentication(request, response, chain, authResult); &#125; &#125; 上面的关键方法attemptAuthentication(request, response);在UsernamePasswordAuthenticationFilter中 12345678910111213141516171819202122232425public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (this.postOnly &amp;&amp; !request.getMethod().equals(\"POST\")) &#123; throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod()); &#125; else &#123; // 通过“username”拿到用户名 String username = this.obtainUsername(request); // 通过\"password\" 拿到密码 String password = this.obtainPassword(request); if (username == null) &#123; username = \"\"; &#125; if (password == null) &#123; password = \"\"; &#125; username = username.trim(); // 传入UsernamePasswordAuthenticationToken构造方法，此类是Authentication的子类 // 此时还没有认证（false） UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); // 交由AuthenticationManager 去处理 return this.getAuthenticationManager().authenticate(authRequest); &#125; &#125; 在UsernamePasswordAuthenticationFilter 的关键流程中，我们将请求的参数进行符合入参的封装， 2、AuthenticationManagerAuthenticationManager本身不包含认证逻辑，其核心是用来管理所有的 AuthenticationProvider，通过交由合适的 AuthenticationProvider 来实现认证。 3、AuthenticationProviderSpring Security 支持多种认证逻辑，每一种认证逻辑的认证方式其实就是一种 AuthenticationProvider。通过 getProviders()方法就能获取所有的AuthenticationProvider，通过provider.supports()来判断 provider 是否支持当前的认证逻辑。 当选择好一个合适的AuthenticationProvider 后，通过 provider.authenticate(authentication) 来让 AuthenticationProvider进行认证。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); AuthenticationException lastException = null; AuthenticationException parentException = null; Authentication result = null; Authentication parentResult = null; boolean debug = logger.isDebugEnabled(); for (AuthenticationProvider provider : getProviders()) &#123; // 判断是否是其支持的provider if (!provider.supports(toTest)) &#123; continue; &#125; if (debug) &#123; logger.debug(\"Authentication attempt using \" + provider.getClass().getName()); &#125; try &#123; // 由具体的provider去进行处理 result = provider.authenticate(authentication); if (result != null) &#123; copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException | InternalAuthenticationServiceException e) &#123; prepareException(e, authentication); // SEC-546: Avoid polling additional providers if auth failure is due to // invalid account status throw e; &#125; catch (AuthenticationException e) &#123; lastException = e; &#125; &#125; if (result == null &amp;&amp; parent != null) &#123; // Allow the parent to try. try &#123; // 如果还是没有结果，交由父类在处理一次 result = parentResult = parent.authenticate(authentication); &#125; catch (ProviderNotFoundException e) &#123; // ignore as we will throw below if no other exception occurred prior to // calling parent and the parent // may throw ProviderNotFound even though a provider in the child already // handled the request &#125; catch (AuthenticationException e) &#123; lastException = parentException = e; &#125; &#125; if (result != null) &#123; if (eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) &#123; // Authentication is complete. Remove credentials and other secret data // from authentication ((CredentialsContainer) result).eraseCredentials(); &#125; // If the parent AuthenticationManager was attempted and successful than it will publish an AuthenticationSuccessEvent // This check prevents a duplicate AuthenticationSuccessEvent if the parent AuthenticationManager already published it if (parentResult == null) &#123; eventPublisher.publishAuthenticationSuccess(result); &#125; return result; &#125; // Parent was null, or didn't authenticate (or throw an exception). if (lastException == null) &#123; lastException = new ProviderNotFoundException(messages.getMessage( \"ProviderManager.providerNotFound\", new Object[] &#123; toTest.getName() &#125;, \"No AuthenticationProvider found for &#123;0&#125;\")); &#125; // If the parent AuthenticationManager was attempted and failed than it will publish an AbstractAuthenticationFailureEvent // This check prevents a duplicate AbstractAuthenticationFailureEvent if the parent AuthenticationManager already published it if (parentException == null) &#123; prepareException(lastException, authentication); &#125; throw lastException; &#125; 4、AbstractUserDetailsAuthenticationProvider表单登录的 AuthenticationProvider主要是由 AbstractUserDetailsAuthenticationProvider 来进行处理的，我们来看下它的 authenticate()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; messages.getMessage( \"AbstractUserDetailsAuthenticationProvider.onlySupports\", \"Only UsernamePasswordAuthenticationToken is supported\")); // Determine username String username = (authentication.getPrincipal() == null) ? \"NONE_PROVIDED\" : authentication.getName(); boolean cacheWasUsed = true; // 默认从缓存中去，如果没有则调用retrieveUser UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (UsernameNotFoundException notFound) &#123; logger.debug(\"User '\" + username + \"' not found\"); if (hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(messages.getMessage( \"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; else &#123; throw notFound; &#125; &#125; Assert.notNull(user, \"retrieveUser returned null - a violation of the interface contract\"); &#125; try &#123; preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (AuthenticationException exception) &#123; if (cacheWasUsed) &#123; // There was a problem, so try again after checking // we're using latest data (i.e. not from the cache) cacheWasUsed = false; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; else &#123; throw exception; &#125; &#125; // 校验密码等信息 postAuthenticationChecks.check(user); // 放入缓存 if (!cacheWasUsed) &#123; this.userCache.putUserInCache(user); &#125; Object principalToReturn = user; if (forcePrincipalAsString) &#123; principalToReturn = user.getUsername(); &#125; // 认证成功后放入认证成功的信息，里面也是放入传入UsernamePasswordAuthenticationToken另一个构造方法 return createSuccessAuthentication(principalToReturn, authentication, user); &#125; 那么关键的retrieveUser里面是什么样呢？ 123456789101112131415161718192021222324protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; prepareTimingAttackProtection(); try &#123; // 用具体的UserDetailSercvice去获取用户信息 UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); if (loadedUser == null) &#123; throw new InternalAuthenticationServiceException( \"UserDetailsService returned null, which is an interface contract violation\"); &#125; return loadedUser; &#125; catch (UsernameNotFoundException ex) &#123; mitigateAgainstTimingAttack(authentication); throw ex; &#125; catch (InternalAuthenticationServiceException ex) &#123; throw ex; &#125; catch (Exception ex) &#123; throw new InternalAuthenticationServiceException(ex.getMessage(), ex); &#125;&#125; 由于我们的用户信息是在UserDetailsServiceAutoConfiguration 的配置类中生成了 InMemoryUserDetailsManager，所以这里的loadUserByUsername的代码则是这样 123456789101112public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserDetails user = users.get(username.toLowerCase()); if (user == null) &#123; throw new UsernameNotFoundException(username); &#125; return new User(user.getUsername(), user.getPassword(), user.isEnabled(), user.isAccountNonExpired(), user.isCredentialsNonExpired(), user.isAccountNonLocked(), user.getAuthorities());&#125; 在内存中维护的用户中去获取，那么如果是其他的用户存储则需要对应的获取方式，如果是保存在数据库那么就需要通过sql语句去获取了，感兴趣的可以直接点击JdbcUserDetailsManager查看相关代码。 其实真个认证的流程到这里也就结束了，至于成功或失败后的逻辑最后还是回到了UsernamePasswordAuthenticationFilter中的结果，如果是成功this.successfulAuthentication(request, response, chain, authResult); 12345678910111213protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \" + authResult); &#125; // 将认证结果放入到上下文中 SecurityContextHolder.getContext().setAuthentication(authResult); this.rememberMeServices.loginSuccess(request, response, authResult); if (this.eventPublisher != null) &#123; this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass())); &#125; // 后去的跳转等信息 this.successHandler.onAuthenticationSuccess(request, response, authResult); &#125; 总结以上便是spring security的认证流程，没想到篇幅会这么长，断点追踪的方式很痛苦，大致方向应该是对的，基本的认证流程也应该浮出水面了。本篇主要是从自动配置的方式出发，后续将展示其他的配置方式甚至自定义认证流程，加油！！！ （完）","categories":[],"tags":[{"name":"spring security","slug":"spring-security","permalink":"https://www.wujiwen.cn/tags/spring-security/"}]},{"title":"【认证与授权】Spring Security系列之初体验","slug":"spring/security/security-cap03","date":"2020-04-07T14:12:46.000Z","updated":"2020-04-08T10:02:46.977Z","comments":true,"path":"2020/04/07/spring/security/security-cap03/","link":"","permalink":"https://www.wujiwen.cn/2020/04/07/spring/security/security-cap03/","excerpt":"本篇将开始Spring Security的学习，将从最简单的搭建工程到自定义配置改造的方式完成一系列的教程。所有的代码将集中在一个工程中，通过不同的module的方式区分每一个篇章，重点突出每个module的特点，关注一个方面的功能或者配置 什么是Spring Security 上面介绍的： ”Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.“ “Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements” 简单点说呢，spring security是一个非常牛的认证与授权框架。在前面的篇幅中我们介绍了，既然是认证与授权框架，那么肯定具备用户登录认证 基于RBAC的授权访问 等功能了?没错。","text":"本篇将开始Spring Security的学习，将从最简单的搭建工程到自定义配置改造的方式完成一系列的教程。所有的代码将集中在一个工程中，通过不同的module的方式区分每一个篇章，重点突出每个module的特点，关注一个方面的功能或者配置 什么是Spring Security 上面介绍的： ”Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.“ “Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements” 简单点说呢，spring security是一个非常牛的认证与授权框架。在前面的篇幅中我们介绍了，既然是认证与授权框架，那么肯定具备用户登录认证 基于RBAC的授权访问 等功能了?没错。 既然这么牛批，那我们就一起来看一下牛在哪里呢？ 由于这是一个系列的学习教程，所以我将通过一个父pom的方式管理多个module，每一个module将负责一块知识点或者配置方式的案例。 初体验 本模块工程名spring-security-basic 接下来我们一起来搭建一个最简单的认证工程 1、pom.xml12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;security-study&lt;/artifactId&gt; &lt;groupId&gt;cn.wujiwen.security&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spring-security-basic&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、启动配置123456789101112131415161718package cn.wujiwen.security.basic;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * Desc: * * @author wujw * @email jiwenwu@outlook.com * @date 2020/4/7 */@SpringBootApplicationpublic class SecurityBasicApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityBasicApplication.class,args); &#125;&#125; 好了！？？？ 没错，好了。我们一起来看一下吧 其实这个时候我们已经完成了一个最简单的登录认证功能了。 spring security在工程启动的时候默认给我们生成了一组用户，可以看到我输入的用户名是user密码是控制台的一组随机字符串。登录成功重定向到了根路径，也就是最开始输入的路径。有人会问了，那不是404嘛，没错！但我们尚未设置根路径访问的资源啊。第一次请求localhost:8080的时候由于系统判定未登录会跳转到登录页面localhost:8080/login 。你可能又会问了，这样的用户名和密码也太奇怪了吧？我们带着这个疑问一起来看一下到底发生了什么？ 自定义用户配置我们找到这个路径org.springframework.boot.autoconfigure.security.SecurityProperties.User会看到这样一段代码 12345678910111213141516171819202122232425262728293031@ConfigurationProperties( prefix = \"spring.security\")public class SecurityProperties &#123; public static final int BASIC_AUTH_ORDER = 2147483642; public static final int IGNORED_ORDER = -2147483648; public static final int DEFAULT_FILTER_ORDER = -100; private final SecurityProperties.Filter filter = new SecurityProperties.Filter(); private SecurityProperties.User user = new SecurityProperties.User(); public SecurityProperties() &#123; &#125; public SecurityProperties.User getUser() &#123; return this.user; &#125; public SecurityProperties.Filter getFilter() &#123; return this.filter; &#125; public static class User &#123; private String name = \"user\"; private String password = UUID.randomUUID().toString(); private List&lt;String&gt; roles = new ArrayList(); private boolean passwordGenerated = true; // 省略 &#125; // 省略&#125; 可以看到在读取默认配置prefix:spring.security时，由于我们的application.yml中什么都没有写，所以默认生成了一个user为用户名UUID为密码的用户信息。知道了这点，我们就可以自定义一个用户信息来覆盖这里的默认配置。 1、application.yml自定义用户 12345spring: security: user: name: admin password: admin 这时重新启动工程，我们就可以用新的用户进行登录了。 2、验证登录用户信息 前面我们提到了，登录成功后会重定向到根路径localhost:8080,为了验证登录的用户信息，我们来添加一个根路径的请求，并返回用户的信息 123456789@RestControllerpublic class BasicController &#123; @RequestMapping(\"/\") public String rootPath(HttpServletRequest request)&#123; Principal userPrincipal = request.getUserPrincipal(); String name = userPrincipal.getName(); return \"您好：\" + name; &#125;&#125; 这个时候启动工程，我们已经发现控制台没有再输出随机的字符密码来，说明我们配置的admin用户已经生效了。 这样我们一个最简单的认证登录流程就完成了，是不是很简单，我们几乎没有做任何配置，只是简单的引入依赖就可以完成流程。初体验完成，后期我们还将继续了解spring security的更多功能并尝试从源码的教育来分析为什么是这样。 （完）","categories":[],"tags":[{"name":"spring security","slug":"spring-security","permalink":"https://www.wujiwen.cn/tags/spring-security/"}]},{"title":"【认证与授权】2、基于session的认证方式","slug":"spring/security/security-cap02","date":"2020-04-05T05:40:13.000Z","updated":"2020-04-08T10:03:43.846Z","comments":true,"path":"2020/04/05/spring/security/security-cap02/","link":"","permalink":"https://www.wujiwen.cn/2020/04/05/spring/security/security-cap02/","excerpt":"这一篇将通过一个简单的web项目实现基于Session的认证授权方式，也是以往传统项目的做法。先来复习一下流程 用户认证通过以后，在服务端生成用户相关的数据保存在当前会话（Session）中，发给客户端的数据将通过session_id存放在cookie中。在后续的请求操作中，客户端将带上session_id，服务端就可以验证是否存在了，并可拿到其中的数据校验其合法性。当用户退出系统或session_id到期时，服务端则会销毁session_id。具体可查看上篇的基本概念了解。","text":"这一篇将通过一个简单的web项目实现基于Session的认证授权方式，也是以往传统项目的做法。先来复习一下流程 用户认证通过以后，在服务端生成用户相关的数据保存在当前会话（Session）中，发给客户端的数据将通过session_id存放在cookie中。在后续的请求操作中，客户端将带上session_id，服务端就可以验证是否存在了，并可拿到其中的数据校验其合法性。当用户退出系统或session_id到期时，服务端则会销毁session_id。具体可查看上篇的基本概念了解。 1. 创建工程本案例为了方便，直接使用springboot快速创建一个web工程 pom.xml1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;simple-mvc&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.2 实现认证功能实现认证功能，我们一般需要这样几个资源 认证的入口（认证页面） 认证的凭证（用户的凭证信息） 认证逻辑（如何才算认证成功） 认证页面也就是我们常说的登录页 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=\"@&#123;/login&#125;\" method=\"post\"&gt; &lt;div&gt;&lt;label&gt; User Name : &lt;input type=\"text\" name=\"username\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; Password: &lt;input type=\"password\" name=\"password\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"登录\"/&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 页面控制器现在有了认证页面，那我如果才可以进入到认证页面呢，同时我点击登陆后，下一步该做什么呢？ 123456789101112131415161718192021@Controllerpublic class LoginController &#123; // 认证逻辑处理 @Autowired private AuthenticationService authenticationService; // 根路径直接跳转至认证页面 @RequestMapping(\"/\") public String loginUrl() &#123; return \"/login\"; &#125; // 认证请求 @RequestMapping(\"/login\") @ResponseBody public String login(HttpServletRequest request) &#123; AuthenticationRequest authenticationRequest = new AuthenticationRequest(request); User user = authenticationService.authentication(authenticationRequest); return user.getUsername() + \"你好！\"; &#125;&#125; 通过客户端传递来的参数进行处理 12345678910public class AuthenticationRequest &#123; private String username; private String password; public AuthenticationRequest(HttpServletRequest request)&#123; username = request.getParameter(\"username\"); password = request.getParameter(\"password\"); &#125; // 省略 setter getter&#125; 同时我们还需要一个状态用户信息的对象User 1234567891011121314public class User &#123; private Integer userId; private String username; private String password; private boolean enable; public User(Integer userId, String username, String password, boolean enable) &#123; this.userId = userId; this.username = username; this.password = password; this.enable = enable; &#125; // 省略 setter getter&#125; 有了用户了，有了入口了，接下来就是对这些数据的处理，看是否如何认证条件了 1234567891011121314151617181920212223242526272829303132@Servicepublic class AuthenticationService&#123; // 模拟数据库中保存的两个用户 private static final Map&lt;String, User&gt; userMap = new HashMap&lt;String, User&gt;() &#123;&#123; put(\"admin\", new User(1, \"admin\", \"admin\", true)); put(\"spring\", new User(2, \"spring\", \"spring\", false)); &#125;&#125;; private User loginByUserName(String userName) &#123; return userMap.get(userName); &#125; @Override public User authentication(AuthenticationRequest authenticationRequest) &#123; if (authenticationRequest == null || StringUtils.isEmpty(authenticationRequest.getUsername()) || StringUtils.isEmpty(authenticationRequest.getPassword())) &#123; throw new RuntimeException(\"账号或密码为空\"); &#125; User user = loginByUserName(authenticationRequest.getUsername()); if (user == null) &#123; throw new RuntimeException(\"用户不存在\"); &#125; if(!authenticationRequest.getPassword().equals(user.getPassword()))&#123; throw new RuntimeException(\"密码错误\"); &#125; if (!user.isEnable())&#123; throw new RuntimeException(\"该账户已被禁用\"); &#125; return user; &#125;&#125; 这里我们模拟了两个用户，一个是正常使用的账号，还有个账号因为某些特殊的原因被封禁了，我们一起来测试一下。 启动项目在客户端输入localhost:8080 会直接跳转到认证页面 我们分别尝试不同的账户密码登录看具体显示什么信息。 1、数据的密码不正确 2、账户被禁用 3、数据正确的用户名和密码 此时我们的测试均已符合预期，能够将正确的信息反馈给用户。这也是最基础的认证功能，用户能够通过系统的认证，说明他是该系统的合法用户，但是用户在后续的访问过程中，我们需要知道到底是哪个用户在操作呢，这时我们就需要引入到会话的功能呢。 1.3 实现会话功能会话是指一个终端用户与交互系统进行通讯的过程，比如从输入账户密码进入操作系统到退出操作系统就是一个会话过程。1、增加会话的控制 关于session的操作，可参考HttpServletRqeust的相关API 前面引言中我们提到了session_id的概念，与客户端的交互。定义一个常量作为存放用户信息的key，同时在登录成功后保存用户信息 123456789privata finl static String USER_SESSION_KEY &#x3D; &quot;user_session_key&quot;;@RequestMapping(&quot;&#x2F;login&quot;)@ResponseBodypublic String login(HttpServletRequest request) &#123; AuthenticationRequest authenticationRequest &#x3D; new AuthenticationRequest(request); User user &#x3D; authenticationService.authentication(authenticationRequest); request.getSession().setAttribute(USER_SESSION_KEY,user); return user.getUsername() + &quot;你好！&quot;;&#125; 2、测试会话的效果 既然说用户认证后，我们将用户的信息保存在了服务端中，那我们就测试一下通过会话，服务端是否知道后续的操作是哪个用户呢？我们添加一个获取用户信息的接口/getUser，看是否能后查询到当前登录的用户信息 12345678910@ResponseBody@RequestMapping(\"/getUser\")public String getUser(HttpServletRequest request)&#123; Object object = request.getSession().getAttribute(\"user_\"); if (object != null)&#123; User user = (User) object; return \"当前访问用户为：\" + user.getUsername(); &#125; return \"匿名用户访问\";&#125; 我们通过客户端传递的信息，在服务端查询是否有用户信息，如果没有则是匿名用户的访问，如果有则返回该用户信息。 首先在不登录下直接访问localhost:8080/getUser 返回匿名用户访问 登陆后再访问返回当前访问用户为：admin 此时我们已经可以看到当认证通过后，后续的访问服务端通过会话机制将知道当前访问的用户是说，这将便于我们进一步处理对用户和资源的控制。 1.4 实现授权功能既然我们知道了是谁在访问用户，接下来我们将对用户访问的资源进行控制。 匿名用户针对部分接口不可访问，提示其认证后再访问 根据用户拥有的权限对资源进行操作（资源查询/资源更新） 1、实现匿名用户不可访问。 前面我们已经可以通过/getUser的接口示例中知道是否是匿名用户，那接下来我们就对匿名用户进行拦截后跳转到认证页面。 1234567891011121314public class NoAuthenticationInterceptor extends HandlerInterceptorAdapter &#123; private final static String USER_SESSION_KEY = \"user_session_key\"; // 前置拦截，在接口访问前处理 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object attribute = request.getSession().getAttribute(USER_SESSION_KEY); if (attribute == null)&#123; // 匿名访问 跳转到根路径下的login.html response.sendRedirect(\"/\"); return false; &#125; return true; &#125;&#125; 然后再将自定义的匿名用户拦截器，放入到web容器中使其生效 12345678@Configurationpublic class WebSecurityConfig implements WebMvcConfigurer &#123; // 添加自定义拦截器,保护路径/protect 下的所有接口资源 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new NoAuthenticationInterceptor()).addPathPatterns(\"/protect/**\"); &#125;&#125; 我们保护/protect 下的所有接口资源，当匿名用户访问上述接口时，都将被系统跳转到认证页面进行认证后才可以访问。 12345@ResponseBody@RequestMapping(\"/protect/getResource\")public String protectResource(HttpServletRequest request)&#123; return \"这是非匿名用户访问的资源\";&#125; 这里我们就不尽兴测试页面的展示了。 2、根据用户拥有的权限对资源进行操作（资源查询/资源更新） 根据匿名用户处理的方式，我们此时也可设置拦截器，对接口的权限和用户的权限进行对比，通过后放行，不通过则提示。此时我们需要配置这样几个地方 用户所具有的权限 一个权限对比的拦截器 一个资源接口 改造用户信息，使其具有相应的权限 12345678910111213141516public class User &#123; private Integer userId; private String username; private String password; private boolean enable; // 授予权限 private Set&lt;String&gt; authorities; public User(Integer userId, String username, String password, boolean enable,Set&lt;String&gt; authorities) &#123; this.userId = userId; this.username = username; this.password = password; this.enable = enable; this.authorities = authorities; &#125;&#125; 重新设置用户 12345678910private static final Map&lt;String, User&gt; userMap = new HashMap&lt;String, User&gt;() &#123;&#123; Set&lt;String&gt; all =new HashSet&lt;&gt;(); all.add(\"read\"); all.add(\"update\"); Set&lt;String&gt; read = new HashSet&lt;&gt;(); read.add(\"read\"); put(\"admin\", new User(1, \"admin\", \"admin\", true,all)); put(\"spring\", new User(2, \"spring\", \"spring\", false,read));&#125;&#125;; 我们将admin用户设置最高权限，具有read和update操作，spring用户只具有read权限 权限拦截器 1234567891011121314151617181920212223242526272829public class AuthenticationInterceptor extends HandlerInterceptorAdapter &#123; private final static String USER_SESSION_KEY = \"user_session_key\"; // 前置拦截，在接口访问前处理 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object attribute = request.getSession().getAttribute(USER_SESSION_KEY); if (attribute == null) &#123; writeContent(response,\"匿名用户不可访问\"); return false; &#125; else &#123; User user = ((User) attribute); String requestURI = request.getRequestURI(); if (user.getAuthorities().contains(\"read\") &amp;&amp; requestURI.contains(\"read\")) &#123; return true; &#125; if (user.getAuthorities().contains(\"update\") &amp;&amp; requestURI.contains(\"update\")) &#123; return true; &#125; writeContent(response,\"权限不足\"); return false; &#125; &#125; //响应输出 private void writeContent(HttpServletResponse response, String msg) throws IOException &#123; response.setContentType(\"text/html;charset=utf‐8\"); PrintWriter writer = response.getWriter(); writer.print(msg); writer.close(); response.resetBuffer(); &#125;&#125; 在分别设置两个操作资源的接口 1234567891011@ResponseBody@RequestMapping(\"/protect/update\")public String protectUpdate(HttpServletRequest request)&#123; return \"您正在更新资源信息\";&#125;@ResponseBody@RequestMapping(\"/protect/read\")public String protectRead(HttpServletRequest request)&#123; return \"您正在获取资源信息\";&#125; 启用自定义拦截器 123456789@Configurationpublic class WebSecurityConfig implements WebMvcConfigurer &#123; // 添加自定义拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new NoAuthenticationInterceptor()).addPathPatterns(\"/protect/**\"); registry.addInterceptor(new AuthenticationInterceptor()).addPathPatterns(\"/protect/**\"); &#125;&#125; 此时我们就可以使用不同的用户进行认证后访问不同的资源来进行测试了。 2、总结当然，这仅仅是最简单的实践，特别是权限处理这一块，很多都是采取硬编码的方式处理，旨在梳理流程相关信息。而在正式的生产环境中，我们将会采取更安全更灵活更容易扩展的方式处理，同时也会使用非常实用的安全框架进行企业级认证授权的处理，例如spring security，shiro等安全框架，在接下来的篇幅中，我们将进入到sping security的学习。加油。 （完）","categories":[],"tags":[{"name":"oauth2","slug":"oauth2","permalink":"https://www.wujiwen.cn/tags/oauth2/"},{"name":"spring security","slug":"spring-security","permalink":"https://www.wujiwen.cn/tags/spring-security/"}]},{"title":"【认证与授权】1、基本概念","slug":"spring/security/security-cap01","date":"2020-03-28T13:54:56.000Z","updated":"2020-04-08T10:04:34.790Z","comments":true,"path":"2020/03/28/spring/security/security-cap01/","link":"","permalink":"https://www.wujiwen.cn/2020/03/28/spring/security/security-cap01/","excerpt":"在互联网中我们一致都有提到或接触到关于认证和授权概念或名字，那到底什么是认证？什么是授权？他们两又有什么联系和区别呢？本系列将记录自己近一段时间学习和实践的过程，以便加深理解过程。 我们先来一起认识两个单词authentication和 authorization，有没有发现什么特点，我第一次接触到的时候，我一直都分不清楚这两个单词的意思（其实就是英语差）。直到后续学习的过程中经常会碰到它们，我才理解了这两个词的意思，在接下来的文章中，你也可能会经常看见它们。 1.1 什么是认证在互联网中，我们每天都会使用到各种各样的APP和网站，在使用过程中通常还会遇到需要注册登录的情况，输入你的用户名和密码才能正常使用，也就是说成为这个应用的合法身份才可以访问应用的资源，这个过程就是认证。当然认证的方式有很多，常见的账号密码登录，手机验证码登录，指纹登录，刷脸登录等等。","text":"在互联网中我们一致都有提到或接触到关于认证和授权概念或名字，那到底什么是认证？什么是授权？他们两又有什么联系和区别呢？本系列将记录自己近一段时间学习和实践的过程，以便加深理解过程。 我们先来一起认识两个单词authentication和 authorization，有没有发现什么特点，我第一次接触到的时候，我一直都分不清楚这两个单词的意思（其实就是英语差）。直到后续学习的过程中经常会碰到它们，我才理解了这两个词的意思，在接下来的文章中，你也可能会经常看见它们。 1.1 什么是认证在互联网中，我们每天都会使用到各种各样的APP和网站，在使用过程中通常还会遇到需要注册登录的情况，输入你的用户名和密码才能正常使用，也就是说成为这个应用的合法身份才可以访问应用的资源，这个过程就是认证。当然认证的方式有很多，常见的账号密码登录，手机验证码登录，指纹登录，刷脸登录等等。 1.2 什么是会话当一个用于认证通过以后，为了避免用户的每次操作都进行认证，这个时候就需要保持一个用户认证状态的会话，常见的认证会话机制有很多，例如session认证，token认证等。 基于session的认证方式 用户认证成功后，在服务端生成用户相关的数据保存在当前会话session中，发给客户端的 SesssionId会存放到 cookie 中，这样用户客户端请求时带上 SesssionId 就可以验证服务器端是否存在 session 数 据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的SesssionId也就无效了。 基于token的认证方式 用户认证成功后，服务端生成一个token发给客户端，客户端可以放到 cookie 或 localStorage等存储中，每次请求时带上 token，服务端收到token通过验证后即可确认用户身份。 基于session的认证方式由Servlet规范定制，服务端要存储session信息需要占用内存资源，客户端需要支持cookie; 基于token的方式则一般不需要服务端存储token，并且不限制客户端的存储方式。如今移动互联网时代 更多类型的客户端需要接入系统，系统多是采用前后端分离的架构进行实现，所以基于token的方式更适合。 1.3 什么是授权 授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有 权限则拒绝访问。例如视频网站的VIP用户，可以查看到普通用户看不到的资源信息。 1.4 授权的数据模型授权过程中，我们需要知道如何对用户访问的资源进行控制，需要了解一些简单的授权数据模型。 授权可以非常简单的理解成谁（Who）对什么（What）进行怎么样（How）的操作。 Who 即主体（Subject），一般指用户，也可以是应用程序 What 即资源（Resource）,例如商品信息，订单信息，页面按钮或程序中的接口等信息。 How 即权限（Permission），规定了用户或程序对资源操作的许可。例如普通用户只能查看订单，管理员可修改或删除订单，这是因为普通用户和管理员用户对订单资源的操作权限不一样。 通常主体、资源、权限相关的数据模型通常会包含以下几个部分 主体Subject（用户ID，账号，密码…） 资源Resource(资源ID,资源名称，访问地址…) 权限Permission(权限ID、权限标识、权限名称，对应的资源ID…) 角色Role(角色ID，角色名称…) 你会发现权限中包含了一个资源ID，多个权限可指向一个资源，我们是否可以直接在权限信息中把资源信息包含进来呢？当然，这也是很多企业开发中的做法，将权限和资源合并为 权限(权限ID、权限标识、权限名称、资源名称、资源访问地址、…) 1.4 RBAC设计模型1.4.1 基于角色的访问控制RBAC基于角色的访问控制(Role-Based Access Control)是按角色进行授权。 例如当用户角色为总经理时，他就可以查询公司的某员工的工资情况，用伪代码的方式我们可以这样表示 123if(Subject.hasRole(\"总经理角色ID\"))&#123; // 查询员工工资&#125; 现在突然来了个需求，要求公司的部门经理也可以查看员工的工资情况，怎么做呢？再加一个判断就好了嘛 123if(Subject.hasRole(\"总经理角色ID\") || Subject.hasRole(\"部门经理角色ID\"))&#123; // 查询员工工资&#125; 这时候我们发现了一个问题，当哪天修改角色的权限时，就需要修改授权相关的代码，系统可扩展性较差。 1.4.2 基于资源的访问控制RBAC基于资源的访问控制(Resource-Based Access Control)是按资源(或权限)进行授权。 同样是上面的需求，这时候我们的代码变成了 123if(Subject.hasPermission(\"查询员工工资的权限标识\"))&#123; // 查询员工工资&#125; 当哪天行政主管角色的用户需要查询员工的工资时，我们只需要为行政主管的角色添加一个查询员工工资的权限即可，不需要去修改授权相关的代码，系统的可扩展性增强了。 （完）","categories":[],"tags":[{"name":"oauth2","slug":"oauth2","permalink":"https://www.wujiwen.cn/tags/oauth2/"},{"name":"spring security","slug":"spring-security","permalink":"https://www.wujiwen.cn/tags/spring-security/"}]},{"title":"Spring 中无处不在的 Properties","slug":"spring/basic/properties-use","date":"2020-01-19T07:46:00.000Z","updated":"2020-01-19T08:04:39.024Z","comments":true,"path":"2020/01/19/spring/basic/properties-use/","link":"","permalink":"https://www.wujiwen.cn/2020/01/19/spring/basic/properties-use/","excerpt":"本文转载自 https://javadoop.com/post/spring-properties 对 Spring 里面的 Properties 不理解的开发者可能会觉得有点乱，主要是因为配置方式很多种，使用方式也很多种。 本文不是原理分析、源码分析文章，只是希望可以帮助读者更好地理解和使用 Spring Properties。 Properties 的使用本文的读者都是使用过 Spring 的，先来看看 Properties 是怎么使用的，Spring 中常用的有以下几种使用方式：","text":"本文转载自 https://javadoop.com/post/spring-properties 对 Spring 里面的 Properties 不理解的开发者可能会觉得有点乱，主要是因为配置方式很多种，使用方式也很多种。 本文不是原理分析、源码分析文章，只是希望可以帮助读者更好地理解和使用 Spring Properties。 Properties 的使用本文的读者都是使用过 Spring 的，先来看看 Properties 是怎么使用的，Spring 中常用的有以下几种使用方式： 1. 在 xml 配置文件中使用即自动替换 ${} 里面的值。 123&lt;bean id=\"xxx\" class=\"com.javadoop.Xxx\"&gt; &lt;property name=\"url\" value=\"$&#123;javadoop.jdbc.url&#125;\" /&gt;&lt;/bean&gt; 2. 通过 @Value 注入使用12@Value(\"$&#123;javadoop.jdbc.url&#125;\")private String url; 3. 通过 Environment 获取此法有需要注意的地方。并不是所有的配置方式都支持通过 Environment 接口来获取属性值，亲测只有使用注解 @PropertySource 的时候可以用，否则会得到 null，至于怎么配置，下面马上就会说。 123456@Autowiredprivate Environment env;public String getUrl() &#123; return env.getProperty(\"javadoop.jdbc.url\");&#125; 如果是 Spring Boot 的 application.properties 注册的，那也是可以的。 Properties 配置前面我们说了怎么使用我们配置的 Properties，那么该怎么配置呢？Spring 提供了很多种配置方式。 1. 通过 xml 配置下面这个是最常用的配置方式了，很多项目都是这么写的： 1&lt;context:property-placeholder location=\"classpath:sys.properties\" /&gt; 2. 通过 @PropertySource 配置前面的通过 xml 配置非常常用，但是如果你也有一种要消灭所有 xml 配置文件的冲动的话，你应该使用以下方式： 12345@PropertySource(\"classpath:sys.properties\")@Configurationpublic class JavaDoopConfig &#123; &#125; 注意一点，@PropertySource 在这里必须搭配 @Configuration 来使用，具体不展开说了。 3. PropertyPlaceholderConfigurer如果读者见过这个，也不必觉得奇怪，在 Spring 3.1 之前，经常就是这么使用的： 123456789&lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:sys.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"ignoreUnresolvablePlaceholders\" value=\"true\"/&gt; &lt;!-- 这里可以配置一些属性 --&gt;&lt;/bean&gt; 当然，我们也可以用相应的 java configuration 的版本： 12345678@Beanpublic PropertyPlaceholderConfigurer propertiess() &#123; PropertyPlaceholderConfigurer ppc = new PropertyPlaceholderConfigurer(); Resource[] resources = new ClassPathResource[]&#123;new ClassPathResource(\"sys.properties\")&#125;; ppc.setLocations(resources); ppc.setIgnoreUnresolvablePlaceholders(true); return ppc;&#125; 4. PropertySourcesPlaceholderConfigurer到了 Spring 3.1 的时候，引入了 PropertySourcesPlaceholderConfigurer，这是一个新的类，注意看和之前的 PropertyPlaceholderConfigurer 在名字上多了一个 Sources，所属的包也不一样，它在 Spring-Context 包中。 在配置上倒是没有什么区别： 123456789&lt;bean class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:sys.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"ignoreUnresolvablePlaceholders\" value=\"true\"/&gt; &lt;!-- 这里可以配置一些属性 --&gt;&lt;/bean&gt; 也来一个 java configuration 版本吧： 12345678@Beanpublic PropertySourcesPlaceholderConfigurer properties() &#123; PropertySourcesPlaceholderConfigurer pspc = new PropertySourcesPlaceholderConfigurer(); Resource[] resources = new ClassPathResource[]&#123;new ClassPathResource(\"sys.properties\")&#125;; pspc.setLocations(resources); pspc.setIgnoreUnresolvablePlaceholders(true); return pspc;&#125; Spring Boot 相关Spring Boot 真的是好东西，开箱即用的感觉实在是太好了。这里简单介绍下相关的内容。 快速生成一个 Spring Boot 项目：https://start.spring.io/ application.properties我们每个项目都默认有一个 application.properties 文件，这个配置文件不需要像前面说的那样进行注册，Spring Boot 会帮我们自动注册。 当然，也许你想换个名字也是可以的，在启动的时候指定你的文件名字就可以了： 1java -Dspring.config.location=classpath:sys.properties -jar app.jar application-{env}.properties为了给不同的环境指定不同的配置，我们会用到这个。 比如测试环境和生产环境的数据库连接信息就不一样。 所以，在 application.properties 的基础上，我们还需要新建 application-dev.properties 和 application-prd.properties，用于配置环境相关的信息，然后启动的时候指定环境。 1java -Dspring.profiles.active=prd -jar app.jar 结果就是，application.properties 和 application-prd.properties 两个文件中的配置都会注册进去，如果有重复的 key，application-prd.properties 文件中的优先级较高。 @ConfigurationProperties这个注解是 Spring Boot 中才有的。 即使大家不使用这个注解，大家也可能会在开源项目中看到这个，这里简单介绍下。 来一个例子直观一些。按照之前说的，在配置文件中填入下面的信息，你可以选择写入 application.properties 也可以用第一节介绍的方法。 123javadoop.database.url=jdbc:mysql:javadoop.database.username=adminjavadoop.database.password=admin123456 java 文件： 12345678@Configuration@ConfigurationProperties(prefix = \"javadoop.database\")public class DataBase &#123; String url; String username; String password; // getters and setters&#125; 这样，就在 Spring 的容器中就自动注册了一个类型为 DataBase 的 bean 了，而且属性都已经 set 好了。 在启动过程中动态修改属性值这个我觉得都不需要太多介绍，用 Spring Boot 的应该基本上都知道。 属性配置有个覆盖顺序，也就是当出现相同的 key 的时候，以哪里的值为准。 启动参数 &gt; application-{env}.properties &gt; application.properties 启动参数动态设置属性： 1java -Djavadoop.database.password=admin4321 -jar app.jar 另外，还可以利用系统环境变量设置属性，还可以指定随机数等等，确实很灵活，不过没什么用，就不介绍了。 总结读者如果想要更加深入地了解 Spring 的 Properties，需要去理解 Spring 的 Environment 接口相关的源码。建议感兴趣的读者去翻翻源代码看看 （全文完）","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.wujiwen.cn/tags/spring/"}]},{"title":"Redis学习与应用-位图","slug":"redis/redis-bitmap","date":"2019-08-20T06:11:03.000Z","updated":"2020-01-20T09:32:24.356Z","comments":true,"path":"2019/08/20/redis/redis-bitmap/","link":"","permalink":"https://www.wujiwen.cn/2019/08/20/redis/redis-bitmap/","excerpt":"什么是位图 位图bitmap是通过一个bit来表示某个元素对应的值或者状态，是由一组bit位组成，每个bit位对应0和1两个状态，虽然内部还是采用string类型进行存储，但是redis提供了直接操作位图的指令，可以把他看作是一个bit数组，数组的下标就是偏移量。","text":"什么是位图 位图bitmap是通过一个bit来表示某个元素对应的值或者状态，是由一组bit位组成，每个bit位对应0和1两个状态，虽然内部还是采用string类型进行存储，但是redis提供了直接操作位图的指令，可以把他看作是一个bit数组，数组的下标就是偏移量。 常用命令介绍一、SETBIT key offset value 可用版本：&gt;=2.20时间复杂度：O(1) 作用对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。当 key 不存在时，自动生成一个新的字符串值。字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。 返回值原来储存的位 示例12345678# 在key值为bitkey的偏移量0处,设置值为1redis&gt; setbit bitkey 0 1# 返回原存储的值(integer) 0# 在key值为bitkey的偏移量0处,设置值为1redis&gt; setbit bitkey 0 0# 返回原存储的值(integer) 1 二、GETBIT key offset 可用版本：&gt;=2.2.0 时间复杂度：O(1) 作用对key 所储存的字符串值，获取指定偏移量上的位(bit)。当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。 返回值字符串值指定偏移量上的位 示例12345678910# 不存在的keyredis&gt;getbit bitkey_0(integer) 0reids&gt;setbit bitkey_0 0 0(integer) 1# 超过默认的偏移量（没有grown）redis&gt;getbit bitkey_0 10000(integer) 0redis&gt;getbit bitkey_0 0(integer) 1 三、 BITCOUNT key [start] [end] 可用版本：&gt;=2.6.0 时间复杂度：O(N) 作用计算给定字符串中，被设置为 1 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置和 GETRANGE key start end 命令类似，都可以使用负数值： 比如 -1 表示最后一个字节， -2 表示倒数第二个字节，以此类推。不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。 示例12345678redis&gt;setbit key_count 0 1(integer) 0redis&gt;setbit key_count 1 1(integer) 0redis&gt;setbit key_count 2 0(integer) 0redis&gt;bitcount key_count(integer) 2 四、BITPOS key bit [start] [end] 可用版本：&gt;= 2.8.7时间复杂度：O(N)，其中N为位图包含的二进制位数量 作用返回位图中第一个值为bit的二进制的位置在默认情况下，命令将检测整个位图，但用户也可以通过start和end参数来指定要检测的范围 返回值整数返回 示例123456redis&gt;setbit key_pos 2 1(integer) 0redis&gt;bitpos key_pos 0(integer) 0redis&gt;bitpos key_pos 1(integer) 2 五、BITOP operation destkey key [key …] 可用版本：&gt;=2.6.0 时间复杂度：O(N) 作用对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种： BITOP AND destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。 BITOP OR destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 BITOP XOR destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。 返回值保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。 示例123456789101112131415161718192021222324# 先保存几组# key_1:1001 key_2:1011 redis&gt; setbit key_1 0 1(integer) 0redis&gt; setbit key_1 3 1(integer) 0redis&gt; setbit key_2 0 1(integer) 0reids&gt; setbit key_2 2 1(integer) 0reids&gt; setbit key_2 3 1(integer) 0# AND key求逻辑并redis&gt; bitop and key_and key_1 key_2 # 结果将是1001(integer) 1# OR key求逻辑或redis&gt; bitop or key_or key_1 key_2 # 1011(integer) 1# XOR key求逻辑异或redis&gt; bitop xor key_xor key_1 key_2 # 0100(integer) 1# NOT key求逻辑非redis&gt; bitop not key_not key_1 # 0110(integer) 1 六、BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL] 可用版本：&gt;= 3.2.0 时间复杂度：每个子命令的复杂度为 O(1) 作用一次对多个位范围进行操作。bitfield 有三个子指令，分别是 get/set/incrby。每个指令都可以对指定片段做操作。 返回值返回一个数组作为回复， 数组中的每个元素就是对应操作的执行结果。 案例123456789101112131415# 从第1位开始取4位，设值为5（有符号数）redis&gt; BITFIELD key SET i4 0 51) (integer) 0# 从第1位开始取4位，结果为有符号数redis&gt; BITFIELD key GET i4 01) (integer) 5# 从第1位取4位，结果为有符号数# 从第5位取4位，设值为6，结果为无符号数# 从第5位去4位，值增加1，结果为无符号数redis&gt; BITFIELD key GET i4 0 SET u4 4 6 INCRBY u4 4 11) (integer) 52) (integer) 03) (integer) 7 BITFIELD还提供了三种溢出策略： WRAP（wrap around，回绕）。一个i8的整数，值为127，递增1会导致值变为-128； SAT（saturation arithmetic，饱和计算）。一个i8的整数，值为120，递增10结果变为127（i8 类型所能储存的最大整数值）； FAIL。 发生溢出时，操作失败。并返回空值表示计算未被执行。 123456789redis&gt; BITFIELD tian_key SET i8 0 127 OVERFLOW WRAP INCRBY i8 0 11) (integer) 02) (integer) -128redis&gt; BITFIELD tian_key_2 SET i8 0 120 OVERFLOW SAT INCRBY i8 0 101) (integer) 02) (integer) 127redis&gt; BITFIELD tian_key_3 SET i8 0 127 OVERFLOW FAIL INCRBY i8 0 11) (integer) 02) (nil)","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.wujiwen.cn/tags/Redis/"}]}],"categories":[],"tags":[{"name":"spring security","slug":"spring-security","permalink":"https://www.wujiwen.cn/tags/spring-security/"},{"name":"oauth2","slug":"oauth2","permalink":"https://www.wujiwen.cn/tags/oauth2/"},{"name":"spring","slug":"spring","permalink":"https://www.wujiwen.cn/tags/spring/"},{"name":"Redis","slug":"Redis","permalink":"https://www.wujiwen.cn/tags/Redis/"}]}